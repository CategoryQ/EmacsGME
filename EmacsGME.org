#+TITLE: EmacsGME
#+DESCRIPTION: A variety of elisp functions for implementing a solo role-playing games-master emulator, for playing a full game within an org-file
#+PROPERTY: header-args :tangle egme.el

* Introduction

The basic idea is to define some functions within Emacs lisp, to facilitate solo role-playing. Then you'll be able to M-x or assign key-binds to quickly roll dice, or get Yes/No oracle results from the GM emulator, fed straight into the document where you are logging your game play. A generic dice roller will be needed (to facilitate any RPG system). As for the GM emulator, I'll need to design a basic system (where outcome likelihood can change), along with a subject/meaning look up table, a way of managing lists of threads/NPCs, and random events popping up.

Initially just some useful functions, possibly to become a minor-mode all of it's own?

* Variables

This section will be for defining any variables due for user customization

** Print Ouptut

The below variables define the "braces" around any games-master output

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
; String printed at the start of games-master output
(setq egme-print-start-line "~~|Games Master|~~~~~~~~~")

; String printed after games-master output
(setq egme-print-end-line "~~~~~~~~~~~~~~~~~~~~~~~~~")
#+END_SRC


* Functions

Below are the planned functions, along with some scratch code testing ideas.

** DONE GM Printed Output
CLOSED: [2021-06-19 Sat 00:39]

This is the core function for output to the user.

Jump to the end of the line, add 2 newlines, add the eGME start, then the function output (in the form of a list of strings?), then the eGME end...

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(defun egme-print-output (print-string)
  "This function takes a string in as an argument, and prints it's output into the current buffer, between lines highlighting it as games-master output.\n\nFor normal text files, the visual braces are stored as the following strings:-\n\n  egme-print-start-line\n  egme-print-end-line\n\n\If the current buffer is an org-mode document, the output is placed inside a quote block so it can retain the bonuses of export fomatting."

  ; Move point to "safe" position
  (end-of-line)
  (newline 2)

  ; Output the start line
  ; Check if current buffer is an org-mode file
  (if (equal (with-current-buffer (current-buffer) major-mode) 'org-mode)
    ; If an org-file, output into a quote block
    (insert "#+BEGIN_QUOTE Games Master")
    ; Else output the opening brace
    (insert egme-print-start-line)
  )
  (newline)

  ; Output text generated by egme functions
  (insert print-string)

  (newline)

  ; Output the end line
  ; Check if current buffer is an org-mode file
  (if (equal (with-current-buffer (current-buffer) major-mode) 'org-mode)
    ; If an org-file, close the quote block
    (insert "#+END_QUOTE")
    ; Else output the closing brace brace
    (insert egme-print-end-line)
  )
  
  (newline 2)
  t
)
#+END_SRC


** DONE Dice Roller
CLOSED: [2021-06-19 Sat 00:39]

*** DONE Using the random function
CLOSED: [2021-06-16 Wed 16:02]
The core of this is obviously the ~random~ function.  The below example shows a single D6 roll - randomly generating a number up to the limit of 6 (integers, 0 1 2 3 4 5), then adding 1 to the result for a normal dice outcome.

#+BEGIN_SRC emacs-lisp :tangle no
(+ (random 6) 1)
#+END_SRC

#+RESULTS:
: 6

~random~ will produce a result up to the given limit, using addition here to add to it (as D6 doesn't have a ~0~ side, D10 would not need that addition for example). Passing the value ~t~ or a string will reseed the pseudo random number generator. Setting a textual seed at the start of each game play file is a good idea, so if it ever gets recalculated the results will be consistent (in the same version of emacs, at least).

#+BEGIN_SRC emacs-lisp :tangle no
(random "This is the RNG seed for this Adventure")
#+END_SRC

#+RESULTS:
: 1835456236453760268

The results output is the seed number generated by the given input string.

*** DONE Getting dice details from user
CLOSED: [2021-06-16 Wed 16:02]

For dice rolls, we will get user input from the mini-buffer using ~read-string~... Below will ask for a dice roll and set it to the variable ~egme-current-dice~. This function will be non-interactive, so it is only called by other functions, so it can be paired with calculation/printing/etc.


The below regexp is used to check if the variable contains a valid dice input, but if there is no leading number then one is inserted.
[1-9][0-9]?[dD][1-9][0-9]*\\([+-][0-9]+\\)?


The dice input function egme-get-dice:-
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(defun egme-get-dice ()
  "Get the required dice-roll from user input on the mini-buffer. Dice rolls to be expected in the usual [number]D[dice-type][modifier] format used by RPGs, for example '2D6' for 2 six-sided dice, or '3d8+2' for 3 eight-sided dice, with 2 added to the result. If the format is given without number (for example 'd100'), then it is assume to be a single dice being rolled.\n\nReturns the dice-type, which is also stored in the variable egme-current-dice - returns nil if input can't be parsed into a dice roll."

  ; Get user input
  (setq egme-current-dice (read-string "Enter dice roll:" egme-current-dice))

  ; Add a leading "1" in case user inputs without type (i.e just "D100")
  (if (string-match "^[dD]" egme-current-dice)
    (setq egme-current-dice (concat "1" egme-current-dice))
  )

  ; Look for string in dice-roll format
  (if (string-match "[1-9][0-9]?[dD][1-9][0-9]*\\([+-][0-9]+\\)?" egme-current-dice)
    ; ***If*** regex matches, set egme-current-dice to the current roll
    (setq egme-current-dice (match-string 0 egme-current-dice))
    ; ***Else*** set it to nil
    (setq egme-current-dice nil)
  )

  egme-current-dice
)
#+END_SRC

The selected dice can later be returned by evaluating it's name.

#+BEGIN_SRC emacs-lisp :tangle no
(egme-get-dice)
#+END_SRC

#+RESULTS:
: 1d20

In the case that a dice-roll cannot be parsed, the output will be ~nil~ so it can be easily read in control functions later.

*** DONE Calculating dice roll
CLOSED: [2021-06-18 Fri 00:18]

Below is how the dice roll is deconstructed.

First it will get the leading digits to see how many dice are being rolled, then the digits following [dD] for the dice type being used, and lastly the modifier. These numbers are stored in the following variables, in case they are required elsewhere later:-
+ ~egme-current-dice-quantity~
+ ~egme-current-dice-type~
+ ~egme-current-dice-modifier~

Once that info has been extracted, it loops the amount of times in the quantity, generating a random number up to the dice type and summing, then applying the modifier. In the case of a multiple D6 type (ie D66/D666/D6666...) then instead of summing the results it treats each roll as a different digit in the final number.

The final result is stored as ~egme-roll-result~ - this is reset to 0 each time this function is called, in the case of error there will be a zero output rather than the results from a previous roll.

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(defun egme-calculate-dice ()
  "Calculates the current dice roll, as stored in the variable egme-current-dice, saving the result in the variable egme-roll-result for further usage.\n\nThis breaks down the current dice into the following variables for calculating:-\n +egme-current-dice-quantity\n +egme-current-dice-type\n +egme-current-dice-modifier\n\nThis function loops for the quantity of dice, summing up random numbers for the appropriate type, then applying the modifier. In the case of a multiple D6 type (ie D66/D666/D6666...) then instead of summing the results it treats each roll as a different digit in the final number.\n\nReturns the result of the roll."

  ; Reset last roll result
  (setq egme-roll-result 0)
  (setq egme-multi-6-temp nil)
  
  ; Get quantity of dice rolled
  (string-match "^[1-9]+" egme-current-dice)
  (setq egme-current-dice-quantity (string-to-number (match-string 0 egme-current-dice)))

  ; Get current dice type
  (string-match "[dD][1-9][0-9]*" egme-current-dice)
  (setq egme-current-dice-type (string-to-number (string-trim-left (match-string 0 egme-current-dice) "[dD]")))

  ; Get modifier (if present, else set to 0)
  (if (string-match "[+-][0-9]+$" egme-current-dice)
    ; If found assign as number
    (setq egme-current-dice-modifier (string-to-number (match-string 0 egme-current-dice)))
    ; If nil, set modifier to 0
    (setq egme-current-dice-modifier 0)
  )

  ; Check if dice type is a D66/D666/D6666 etc
  (if (string-match "^66+$" (number-to-string egme-current-dice-type))
    ; If a multi-6 dice, roll each D6 and combine as string, then repeat for each quantity of rolls
    (dotimes (n egme-current-dice-quantity)
      (dotimes (n (length (number-to-string egme-current-dice-type)))
        (setq egme-multi-6-temp (concat egme-multi-6-temp (number-to-string (+ 1 (random 6)))))
      )
      (setq egme-roll-result (string-to-number egme-multi-6-temp))
    )

    ;Else calculate dice as usual
    ; Loop the amount of dice, generating a random number for each
    (dotimes (n egme-current-dice-quantity)
      (setq egme-roll-result (+ egme-roll-result (+ 1 (random egme-current-dice-type))))
    )
  )
  ; Add the modifier to the result, for the final roll
  (setq egme-roll-result (+ egme-roll-result egme-current-dice-modifier))

  egme-roll-result
)
#+END_SRC


Output test:-

#+BEGIN_SRC emacs-lisp :tangle no
(egme-get-dice)
(egme-calculate-dice)
;egme-current-dice-quantity
;egme-current-dice-type
;egme-current-dice-modifier
#+END_SRC

#+RESULTS:
: 9

*** DONE User dice roll function (with output)
CLOSED: [2021-06-19 Sat 00:38]

This function is how the user is expected to interact with the dice roller (typically via a key-bind). It will call the egme-get-dice command, followed by the egme-calculate-dice command, and then output the info in a human-readable format - with a smattering of error-checking along the way.

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(defun egme-roll-dice ()
  "This function is for a user to generate the results from a dice roll, and output them into the current buffer.\n\negme-get-dice is called to get user input, egme-calculate dice is used to generate the result, and egme-print-output is used to place this into the current buffer, creating new lines below the point.\n\nThis function is interactively callable via M-x, and a prime input option for key-binding."
  ; Let user call via M-x
  (interactive)

  ; Get dice size from user
  (egme-get-dice)

  ; Check dice input was correct
  (if egme-current-dice
    ; If valid then calculate result
    (egme-calculate-dice)
    ; Else drop an error message and exit
    (user-error "Could not parse dice roll")
  )

  ; Print results
  (egme-print-output (concat (format "Rolled:  %s" egme-current-dice) (format "\nResult:  %s" egme-roll-result)))
  egme-roll-result
)
#+END_SRC


** TODO Yes/No Oracle

** TODO Random Events

