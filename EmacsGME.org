#+TITLE: EmacsGME
#+DESCRIPTION: A variety of elisp functions for implementing a solo roleplaying gamesmaster emulator, for playing a full game within an org-file
#+PROPERTY: header-args :tangle egme.el

* Introduction

The basic idea is to define some functions within emacs lisp, to facilitate solo roleplaying. Then you'll be able to M-x or assign keybinds to quickly roll dice, or get Yes/No oracle results from the GM emulator, fed straight into the document where you are logging your game play. A generic dice roller will be needed (to facilitate any RPG system). As for the GM emulator, I'll need to desgn a basic system (where outcome likelihood cna change), along with a subject/meaning look up table, a way of managing lists of threads/NPCs, and random events poppng up.

Initially just some useful functions, possibly to become a minor-mode all of it's own?

* Functions

Below are the planned functions, along with some scratch code testing ideas.

** TODO Dice Roller

*** DONE Using the random function
CLOSED: [2021-06-16 Wed 16:02]
The core of this is obviously the ~random~ function.  The below example shows a single D6 roll - randomly generating a number up to the limit of 6 (integers, 0 1 2 3 4 5), then adding 1 to the result for a normal dice outcome.

#+BEGIN_SRC emacs-lisp :tangle no
(+ (random 6) 1)
#+END_SRC

#+RESULTS:
: 4

~random~ will produce a result up to the given limit, using addition here to add to it (as D6 doesn't have a ~0~ side, D10 would not need that addition for example). Passing the value ~t~ or a string will reseed the psuedo random number generator. Setting a textual seed at the start of each gameplay file is a good idea, so if it ever get's recalculated the results will be consistent (in the same version of emacs, at least).

#+BEGIN_SRC emacs-lisp :tangle no
(random "This is the RNG seed for this Adventure")
#+END_SRC

#+RESULTS:
: 1835456236453760268

The results output is the seed number generated by the given input string.

*** DONE Getting dice details from user
CLOSED: [2021-06-16 Wed 16:02]

For dice rolls, we will get user input from the minibuffer using ~read-string~... Below will ask for a dice roll and set it to the variable ~egme-current-dice~. This function will be non-interactive, so it is only called by other functions, so it can be paired with calculation/printing/etc.


The below regexp is used to check if the variable contains a valid dice input, but if there is no leading number then one is inserted.
[1-9][0-9]?[dD][1-9][0-9]*\\([+-][0-9]+\\)?


The dice input function egme-get-dice:-
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(defun egme-get-dice ()
  "Get the required dice-roll from user input on the minibuffer. Dice rolls to be expected in the usual [number]D[dicetype][modifier] format used by RPGs, for example '2D6' for 2 six-sided dice, or '3d8+2' for 3 eight-sided dice, with 2 added to the result. If the format is given without number (for example 'd100'), then it is assume to be a single dice being rolled.\n\nDice-type is stored in the variable egme-current-dice, set to nil if input can't be parsed into a dice roll."

  ; Get user input
  (setq egme-current-dice (read-string "Enter dice roll:" egme-current-dice))

  ; Add a leading "1" in case user inputs without type (i.e just "D100")
  (if (string-match "^[dD]" egme-current-dice)
    (setq egme-current-dice (concat "1" egme-current-dice))
  )

  ; Look for string in dice-roll format
  (if (string-match "[1-9][0-9]?[dD][1-9][0-9]*\\([+-][0-9]+\\)?" egme-current-dice)
    ; ***If*** regex matches, set egme-current-dice to the current roll
    (setq egme-current-dice (match-string 0 egme-current-dice))
    ; ***Else*** set it to nil
    (setq egme-current-dice nil)
  )
)
#+END_SRC

#+RESULTS:
: egme-get-dice


The selected dice can later be returned by evaluating it's name.

#+BEGIN_SRC emacs-lisp :tangle no
(egme-get-dice)
egme-current-dice
#+END_SRC

#+RESULTS:
: 2d6+2

In the case that a dice-roll cannot be parsed, the output will be ~nil~ so it can be easily read in control functions later.

*** TODO Calculating dice roll

Below is how the dice roll is deconstructed.

First it will get the leading digits to see how many dice are being rolled, then the digits following [dD] for the dice type being used, and lastly the modifier. These numbers are stored in the following variables, in case they are required elsewhere later:-
+ ~egme-current-dice-quantity~
+ ~egme-current-dice-type~
+ ~egme-current-dice-modifier~

Once that info has been extracted, it loops the amount of times in the quantity, generating a random number up to the dice type, and applying the modifier.

The final result is stored as ~egme-roll-result~ - this is reset to 0 each time this function is called, in the case of error there will be a zero output rather than the results from a previous roll.

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(defun egme-calculate-dice ()
  "Calculates the current dice roll, as stored in the variable egme-current-dice, saving the result in the variable egme-roll-result for further usage. In the case a dice result isn't calculated correctly for  some reason, it will return 'nil'.\n\nThis breaks down the current dice into the following variables for calculating:-\n +egme-current-dice-quantity\n +egme-current-dice-type\n +egme-current-dice-modifier\n\nThis function loops for the quantity of dice, summing up random numbers for the appropriate type, then applying the modifier. In the case of a multiple D6 type (ie D66/D666/D6666...) then instead of summing the results it treats each roll as a differnet digit in the final number."

  ; Reset last roll result
  (setq egme-roll-result 0)
  (setq egme-multi-6-temp nil)
  
  ; Get quantity of dice rolled
  (string-match "^[1-9]+" egme-current-dice)
  (setq egme-current-dice-quantity (string-to-number (match-string 0 egme-current-dice)))

  ; Get current dice type
  (string-match "[dD][1-9][0-9]*" egme-current-dice)
  (setq egme-current-dice-type (string-to-number (string-trim-left (match-string 0 egme-current-dice) "[dD]")))

  ; Get modifier (if present, else set to 0)
  (if (string-match "[+-][0-9]+$" egme-current-dice)
    ; If found assign as number
    (setq egme-current-dice-modifier (string-to-number (match-string 0 egme-current-dice)))
    ; If nil, set modifier to 0
    (setq egme-current-dice-modifier 0)
  )

  ; Check if dice type is a D66/D666/D6666 etc
  (if (string-match "^66+$" (number-to-string egme-current-dice-type))
    ; If a multi-6 dice, roll each D6 and combine as string, then repeat for each quantity of rolls
    (dotimes (n egme-current-dice-quantity)
      (dotimes (n (length (number-to-string egme-current-dice-type)))
        (setq egme-multi-6-temp (concat egme-multi-6-temp (number-to-string (+ 1 (random 6)))))
      )
      (setq egme-roll-result (string-to-number egme-multi-6-temp))
    )

    ;Else calculate dice as usual
    ; Loop the amount of dice, generating a random number for each
    (dotimes (n egme-current-dice-quantity)
      (setq egme-roll-result (+ egme-roll-result (+ 1 (random egme-current-dice-type))))
    )
  )
  ; Add the modifier to the result, for the final roll
  (setq egme-roll-result (+ egme-roll-result egme-current-dice-modifier))

  ; If the roll-result is a zero, something has gone wrong so change that to "nil"
  (if (equal 0 egme-roll-result)
    (setq egme-roll-result nil)
  )
)
#+END_SRC


Output test:-

#+BEGIN_SRC emacs-lisp :tangle no
(egme-get-dice)
(egme-calculate-dice)
;egme-current-dice-quantity
;egme-current-dice-type
;egme-current-dice-modifier
egme-roll-result
#+END_SRC

#+RESULTS:
: 53


** TODO Yes/No Oracle

** TODO Random Events

