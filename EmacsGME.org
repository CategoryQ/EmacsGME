#+TITLE: EmacsGME
#+DESCRIPTION: A variety of elisp functions for implementing a solo role-playing games-master emulator, for playing a full game within an org-file
#+PROPERTY: header-args :tangle egme.el

* Introduction

The basic idea is to define some functions within Emacs lisp, to facilitate solo role-playing. Then you'll be able to M-x or assign key-binds to quickly roll dice, or get Yes/No oracle results from the GM emulator, fed straight into the document where you are logging your game play. A generic dice roller will be needed (to facilitate any RPG system). As for the GM emulator, I'll need to design a basic system (where outcome likelihood can change), along with a subject/meaning look up table, a way of managing lists of threads/NPCs, and random events popping up.


* Variables

This section will be for defining any variables due for user customization

** Print Ouptut

The below variables define the "braces" around any games-master output

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
; String printed at the start of games-master output
(setq egme-print-start-line "~~|Games Master|~~~~~~~~~")

; String printed after games-master output
(setq egme-print-end-line "~~~~~~~~~~~~~~~~~~~~~~~~~")
#+END_SRC

** History Lists

The below sets a list to be used for the dice roll function's history

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(setq egme-dice-history (list))
#+END_SRC

** Probability List

The below list is used for selecting probabilities when asking yes/no questions

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
; Standard probability list for ido-completing-read
(setq egme-probability-list (list
  "0  Even odds"
  "-1  Unlikely"
  "-2  Very Unlikely"
  "-3  Extremely Unlikely"
  "-4  Near Impossible"
  "+4  Near Certain"
  "+3  Extremely Likely"
  "+2  Very Likely"
  "+1  Likely")
)
#+END_SRC

** Action/Subject Lists

The below action/subject lists are for random events & detailed questions. The word lists have come from my [[https://quintendo.uk/category/solo-sci-fi-sidekick/][Solo Sci-Fi Sidekick]] cards project.

*** Actions

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(setq egme-action-list (list
  "Abandon"
  "Abuse"
  "Adversity"
  "Agree"
  "Ambush"
  "Antagonise"
  "Arrive"
  "Assist"
  "Attach"
  "Befriend"
  "Bestow"
  "Betray"
  "Block"
  "Break"
  "Celebrate"
  "Change"
  "Communicate"
  "Control"
  "Create"
  "Cruelty"
  "Deceive"
  "Delay"
  "Desert"
  "Develop"
  "Dispute"
  "Disrupt"
  "Divide"
  "Dominate"
  "Expose"
  "Failure"
  "Fight"
  "Gratify"
  "Guide"
  "Harm"
  "Heal"
  "Immitate"
  "Imprison"
  "Inform"
  "Inquire"
  "Inspect"
  "Intolerance"
  "Judge"
  "Kill"
  "Malice"
  "Mistrust"
  "Move"
  "Neglect"
  "Open"
  "Oppose"
  "Oppress"
  "Passion"
  "Persecute"
  "Praise"
  "Procrastinate"
  "Propose"
  "Punish"
  "Pursue"
  "Release"
  "Return"
  "Ruin"
  "Separate"
  "Spy"
  "Starting"
  "Stop"
  "Take"
  "Transform"
  "Travel"
  "Trick"
  "Trust"
  "Violate"
  "Waste"
  "Work")
)
#+END_SRC


*** Subject

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(setq egme-subject-list (list
   "A path"
  "A project"
  "Adversities"
  "Advice"
  "Allies"
  "Ambush"
  "Animals"
  "Art"
  "Attention"
  "Balance"
  "Bureaucracy"
  "Business"
  "Competition"
  "Danger"
  "Death"
  "Dispute"
  "Disruption"
  "Dreams"
  "Elements"
  "Emotions"
  "Energy"
  "Environment"
  "Expectations"
  "Extravagance"
  "Failure"
  "Fame"
  "Fears"
  "Friendship"
  "Goals"
  "Home"
  "Hope"
  "Illness"
  "Information"
  "Inside"
  "Intrigues"
  "Jealousy"
  "Joy"
  "Leadership"
  "Lies"
  "Masses"
  "Messages"
  "Military"
  "Nature"
  "New ideas"
  "Opposition"
  "Outside"
  "Pain"
  "Peace"
  "Plans"
  "Pleasures"
  "Portals"
  "Possessions"
  "Power"
  "Prison"
  "Randomness"
  "Reality"
  "Riches"
  "Rumor"
  "Stalemate"
  "Status quo"
  "Success"
  "Suffering"
  "Tactics"
  "Technology"
  "Travel"
  "Trials"
  "Vehicle"
  "Victory"
  "Weapons"
  "Weather"
  "Wishes"
  "Wounds")
)
#+END_SRC


* Functions

Below are the planned functions, along with some scratch code testing ideas.

** DONE GM Printed Output
CLOSED: [2021-06-19 Sat 00:39]

This is the core function for output to the user.

Jump to the end of the line, add 2 newlines, add the eGME start, then the function output (in the form of a list of strings?), then the eGME end...

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(defun egme-print-output (print-string)
  "This function takes a string in as an argument, and prints it's output into the current buffer, between lines highlighting it as games-master output.

For normal text files, the visual braces are stored as the following strings:-

  egme-print-start-line
  egme-print-end-line

If the current buffer is an org-mode document, the output is placed inside a quote block so it can retain the bonuses of export fomatting."

  ; Move point to "safe" position
  (end-of-line)
  (newline 2)

  ; Output the start line
  ; Check if current buffer is an org-mode file
  (if (equal (with-current-buffer (current-buffer) major-mode) 'org-mode)
    ; If an org-file, output into a quote block
    (insert "#+BEGIN_QUOTE Games Master")
    ; Else output the opening brace
    (insert egme-print-start-line)
  )
  (newline)

  ; Output text generated by egme functions
  (insert print-string)

  (newline)

  ; Output the end line
  ; Check if current buffer is an org-mode file
  (if (equal (with-current-buffer (current-buffer) major-mode) 'org-mode)
    ; If an org-file, close the quote block
    (insert "#+END_QUOTE")
    ; Else output the closing brace brace
    (insert egme-print-end-line)
  )
  
  (newline 2)
  t
)
#+END_SRC


** DONE Dice Roller
CLOSED: [2021-06-19 Sat 00:39]

*** DONE Using the random function
CLOSED: [2021-06-16 Wed 16:02]
The core of this is obviously the ~random~ function.  The below example shows a single D6 roll - randomly generating a number up to the limit of 6 (integers, 0 1 2 3 4 5), then adding 1 to the result for a normal dice outcome.

#+BEGIN_SRC emacs-lisp :tangle no
(+ (random 6) 1)
#+END_SRC

#+RESULTS:
: 1

~random~ will produce a result up to the given limit, using addition here to add to it (as D6 doesn't have a ~0~ side, D10 would not need that addition for example). Passing the value ~t~ or a string will reseed the pseudo random number generator. Setting a textual seed at the start of each game play file is a good idea, so if it ever gets recalculated the results will be consistent (in the same version of emacs, at least).

#+BEGIN_SRC emacs-lisp :tangle no
(random "This is the RNG seed for this Adventure")
#+END_SRC

#+RESULTS:
: 1835456236453760268

The results output is the seed number generated by the given input string.

*** DONE Getting dice details from user
CLOSED: [2021-06-16 Wed 16:02]

For dice rolls, we will get user input from the mini-buffer using ~read-string~... Below will ask for a dice roll and set it to the variable ~egme-current-dice~. This function will be non-interactive, so it is only called by other functions, so it can be paired with calculation/printing/etc.


The below regexp is used to check if the variable contains a valid dice input, but if there is no leading number then one is inserted.
[1-9][0-9]?[dD][1-9][0-9]*\\([+-][0-9]+\\)?

A history of dice rolls requested is stored in the variable ~egme-dice-history~, and if no user input at-all is given then the last input is repeated.

The dice input function egme-get-dice:-
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defun egme-get-dice ()
    "Get the required dice-roll from user input on the mini-buffer. Dice rolls to be expected in the usual [number]D[dice-type][modifier] format used by RPGs, for example '2D6' for 2 six-sided dice, or '3d8+2' for 3 eight-sided dice, with 2 added to the result. If the format is given without number (for example 'd100'), then it is assume to be a single dice being rolled.

If no input is given, then it will return the last dice rolled. A full history of rolls is stored in 'egme-dice-history', accessible via the arrow keys when asked for input.

Returns the dice-type, which is also stored in the variable egme-current-dice - returns nil if input can't be parsed into a dice roll."
    
    ; Get user input
    (setq egme-current-dice (read-string (format "Enter dice roll (default %s): " (car egme-dice-history)) nil 'egme-dice-history (car egme-dice-history)))
  
    ; Add a leading "1" in case user inputs without type (i.e just "D100")
    (if (string-match "^[dD]" egme-current-dice)
        (setq egme-current-dice (concat "1" egme-current-dice))
      )
  
    ; Look for string in dice-roll format
    (if (string-match "[1-9][0-9]?[dD][1-9][0-9]*\\([+-][0-9]+\\)?" egme-current-dice)
        ; ***If*** regex matches, set egme-current-dice to the current roll
        (setq egme-current-dice (match-string 0 egme-current-dice))
      ; ***Else*** set it to nil
      (setq egme-current-dice nil)
      )
  
    egme-current-dice
  )
#+END_SRC

The selected dice can later be returned by evaluating it's name.

#+BEGIN_SRC emacs-lisp :tangle no
(egme-get-dice)
#+END_SRC

#+RESULTS:
: 2d6

In the case that a dice-roll cannot be parsed, the output will be ~nil~ so it can be easily read in control functions later.

*** DONE Calculating dice roll
CLOSED: [2021-06-18 Fri 00:18]

Below is how the dice roll is deconstructed.

First it will get the leading digits to see how many dice are being rolled, then the digits following [dD] for the dice type being used, and lastly the modifier. These numbers are stored in the following variables, in case they are required elsewhere later:-
+ ~egme-current-dice-quantity~
+ ~egme-current-dice-type~
+ ~egme-current-dice-modifier~

Once that info has been extracted, it loops the amount of times in the quantity, generating a random number up to the dice type and summing, then applying the modifier. In the case of a multiple D6 type (ie D66/D666/D6666...) then instead of summing the results it treats each roll as a different digit in the final number.

The final result is stored as ~egme-roll-result~ - this is reset to 0 each time this function is called, in the case of error there will be a zero output rather than the results from a previous roll.

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(defun egme-calculate-dice ()
  "Calculates the current dice roll, as stored in the variable egme-current-dice, saving the result in the variable egme-roll-result for further usage.

This breaks down the current dice into the following variables for calculating:-
 +egme-current-dice-quantity
 +egme-current-dice-type
 +egme-current-dice-modifier

This function loops for the quantity of dice, summing up random numbers for the appropriate type, then applying the modifier. In the case of a multiple D6 type (ie D66/D666/D6666...) then instead of summing the results it treats each roll as a different digit in the final number.

Returns the result of the roll."

  ; Reset last roll result
  (setq egme-roll-result 0)
  (setq egme-multi-6-temp nil)
  
  ; Get quantity of dice rolled
  (string-match "^[1-9]+" egme-current-dice)
  (setq egme-current-dice-quantity (string-to-number (match-string 0 egme-current-dice)))

  ; Get current dice type
  (string-match "[dD][1-9][0-9]*" egme-current-dice)
  (setq egme-current-dice-type (string-to-number (string-trim-left (match-string 0 egme-current-dice) "[dD]")))

  ; Get modifier (if present, else set to 0)
  (if (string-match "[+-][0-9]+$" egme-current-dice)
    ; If found assign as number
    (setq egme-current-dice-modifier (string-to-number (match-string 0 egme-current-dice)))
    ; If nil, set modifier to 0
    (setq egme-current-dice-modifier 0)
  )

  ; Check if dice type is a D66/D666/D6666 etc
  (if (string-match "^66+$" (number-to-string egme-current-dice-type))
    ; If a multi-6 dice, roll each D6 and combine as string, then repeat for each quantity of rolls
    (dotimes (n egme-current-dice-quantity)
      (dotimes (n (length (number-to-string egme-current-dice-type)))
        (setq egme-multi-6-temp (concat egme-multi-6-temp (number-to-string (+ 1 (random 6)))))
      )
      (setq egme-roll-result (string-to-number egme-multi-6-temp))
    )

    ;Else calculate dice as usual
    ; Loop the amount of dice, generating a random number for each
    (dotimes (n egme-current-dice-quantity)
      (setq egme-roll-result (+ egme-roll-result (+ 1 (random egme-current-dice-type))))
    )
  )
  ; Add the modifier to the result, for the final roll
  (setq egme-roll-result (+ egme-roll-result egme-current-dice-modifier))

  egme-roll-result
)
#+END_SRC


Output test:-

#+BEGIN_SRC emacs-lisp :tangle no
(egme-get-dice)
(egme-calculate-dice)
;egme-current-dice-quantity
;egme-current-dice-type
;egme-current-dice-modifier
#+END_SRC

#+RESULTS:
: 4

*** DONE User dice roll function (with output)
CLOSED: [2021-06-19 Sat 00:38]

This function is how the user is expected to interact with the dice roller (typically via a key-bind). It will call the egme-get-dice command, followed by the egme-calculate-dice command, and then output the info in a human-readable format - with a smattering of error-checking along the way.

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(defun egme-roll-dice ()
  "This function is for a user to generate the results from a dice roll, and output them into the current buffer.

egme-get-dice is called to get user input, egme-calculate dice is used to generate the result, and egme-print-output is used to place this into the current buffer, creating new lines below the point.

This function is interactively callable via M-x, and a prime input option for key-binding."
  ; Let user call via M-x
  (interactive)

  ; Get dice size from user
  (egme-get-dice)

  ; Check dice input was correct
  (if egme-current-dice
    ; If valid then calculate result
    (egme-calculate-dice)
    ; Else drop an error message and exit
    (user-error "Could not parse dice roll")
  )

  ; Print results
  (egme-print-output (concat (format "Rolled:  %s" egme-current-dice) (format "\nResult:  %s" egme-roll-result)))
  egme-roll-result
)
#+END_SRC


** TODO Yes/No Oracle

For the oracle, there is a list of different options for the probabilty of a success (likely/even odds/unlikely/etc..) which the user selects interactively. This is seleceted via the function ~ido-completing-read~, using the left & right keys.

For the Oracle, you roll ~1D10~ - on a 6+ the answer is "Yes", on a 5 or less the answer is "No" - this dice roll is modified based on the following probabilities:-
- Near Certain (+4)
- Extremely Likely (+3)
- Very Likely (+2)
- Likely (+1)
- 50/50 (0)
- Unlikely (-1)
- Very Unlikely (-2)
- Extremely Unlikely (-3)
- Near Impossible (-4)

This result can be transformed further. ~1D8~ is rolled alongside this, and on a roll of 1 the result is appened with ", but..", on a roll of 2 it's appended with ", and..." - anything else is ignored. These modifiers are to be interpreted as a partial result ("but" implies some hinderance to the answer) or an extreme result ("and" implies the answer goes beyond what is expected) respectively.

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defun egme-y-n-oracle ()
    "The basic oracle function. This will provide Yes/No answers to questions posed to the games master, and outputs the results in the current buffer in the standard games master format.

The user will be asked to input a question - if provided, the question will be printed along with the results.
Next, the user will be asked for the likelihood of this result. These options are stored in the list egme-probability-list, and selected via ido-completing-read. Each option is a modifier between -4 and +4, along with a basic description of the probability. 
The answer is generated by rolling 1D10 and applying the chosen modifier, any result of a 6+ will be a 'Yes', anything else a 'No'. A D6 is also rolled, to see if it is an extreme answer - on a 1 it is a minor result (', but...'), and on a 2 it is a major result (', and...').

The function egme-random-event is also called to see if anything unexpected occurs - any change will be added to the variable egme-oracle-output before it gets passed on for user output."
    (interactive)

    ; Reset some variables
    (setq egme-oracle-ouput nil)
    (setq egme-oracle-answer nil)
    (setq egme-current-question nil)
    
    ; Get the user to input a question
    (setq egme-current-question (read-string "What is the question?: "))

    ; Get probability from the user
    (setq egme-current-probability-choice (ido-completing-read "Probability modifier: " egme-probability-list))

    (string-match "[+\-]?[0-9]" egme-current-probability-choice)
    (setq egme-current-probability-modifier (match-string 0 egme-current-probability-choice))
    
    ; Roll dice, apply modifier
    (setq egme-oracle-answer-roll (+ (egme-calculate-dice "1d10") (string-to-number egme-current-probability-modifier)))
    (setq egme-oracle-answer-modifier (egme-calculate-dice "1d6"))

    ; Convert dice rolls into result text - check if modified oracle roll is 6+ ('Yes')
    (if (>= egme-oracle-answer-roll 6)
      ; If greater, then answer yes
      (setq egme-oracle-answer "Yes")
      ; Else answer no
      (setq egme-oracle-answer "No")
    )

    ; Apply answer modifier (if applicable)
    ; Add 'but' if rolled 1, add 'and' if rolled 2
    (cond ((eq egme-oracle-answer-modifier 1) (setq egme-oracle-answer (concat (format "%s" egme-oracle-answer) ", but...")))
          ((eq egme-oracle-answer-modifier 2) (setq egme-oracle-answer (concat (format "%s" egme-oracle-answer) ", and...")))
    )      


    ;; Prepare output for printing
    ; Check if a question was input...
    (if (string-match "[A-Z][a-z]" egme-current-question)
      ; ..then add quesiton to the output with results
      (setq egme-oracle-output (format "   Question:  %s\n" egme-current-question))
      (setq egme-oracle-output "")
    )

    ; Get probability text
    (string-match "[A-Za-z][A-Za-z ]*" egme-current-probability-choice)
    (setq egme-probability-text (match-string 0 egme-current-probability-choice))

    ; Add probability and results to output
    (setq egme-oracle-output (concat egme-oracle-output (format "Probability:  %s\n" egme-probability-text) (format "\n     Answer:  %s" egme-oracle-answer)))

    ; Send output string to display to user 
    (egme-print-output egme-oracle-output)

  )
#+END_SRC


** TODO Random Events

The following function will be called from the oracle, and check to see if a random event happened. If so, it will append the details of the random event to ~egme-oracle-output~ to be printed along with the normal outcome of the question.

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(defun egme-random-event ()
  "A function for genereating unexpected events. ADD MORE TEXT HERE."
  
  nil
)
#+END_SRC
